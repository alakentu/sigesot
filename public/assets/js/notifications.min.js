/**
 * notifications.min.js - Versión 3.4
 * Solución completa con todos los métodos implementados
 */
(function () {
  'use strict';

  // Configuración base
  const config = {
    baseUrl: (() => {
      try {
        const pathSegment = window.location.pathname.split('/')[1] || '';
        return new URL(`${window.location.origin}/${pathSegment}`).href.replace(/\/$/, '');
      } catch (e) {
        console.error('Error construyendo base_url:', e);
        return window.location.origin;
      }
    })(),
    endpoints: {
      markAsRead: '/admin/tickets/mark_as_read',
      notifications: '/admin/tickets/notifications'
    },
    paths: {
      sounds: '/assets/sounds/',
      icons: '/assets/images/icons/'
    },
    intervals: {
      polling: 30000,
      toast: 5000
    },
    sounds: {
      'alta': 'alarm.mp3',
      'media': 'alert.mp3',
      'baja': 'notify.mp3'
    }
  };

  class NotificationManager {
    constructor() {
      this.state = {
        notifications: [],
        isFetching: false,
        soundCache: {},
        pollingInterval: null
      };

      this.elements = {
        container: document.getElementById('notifications-container'),
        badge: document.getElementById('notification-badge'),
        dropdown: document.getElementById('notification-dropdown')
      };

      this.init();
    }

    async init() {
      if (!this.checkDependencies()) return;

      this.setupEventListeners();
      this.preloadSounds(); // Método ahora implementado
      await this.loadNotifications();
      this.startPolling();

      const ticketId = this.getTicketIdFromUrl();
      if (ticketId) await this.markAsRead([ticketId]);
    }

    checkDependencies() {
      if (!this.elements.container || !this.elements.badge) {
        console.error('Elementos del DOM no encontrados');
        return false;
      }
      return true;
    }

    // Método preloadSounds implementado
    preloadSounds() {
      Object.entries(config.sounds).forEach(([priority, soundFile]) => {
        try {
          const audio = new Audio(config.baseUrl + config.paths.sounds + soundFile);
          audio.load(); // Esta línea fue modificada
          this.state.soundCache[soundFile] = audio;
        } catch (error) {
          console.error(`Error creando audio para ${priority}:`, error);
        }
      });
    }

    // Método updateBadge implementado
    updateBadge(unreadCount) {
      if (!this.elements.badge) return;

      this.elements.badge.textContent = unreadCount;
      this.elements.badge.classList.toggle('d-none', unreadCount === 0);

      // Actualizar título del documento si hay notificaciones
      if (unreadCount > 0) {
        document.title = `(${unreadCount}) ${document.title.replace(/^\(\d+\)\s/, '')}`;
      } else {
        document.title = document.title.replace(/^\(\d+\)\s/, '');
      }
    }

    setupEventListeners() {
      document.getElementById('navbarDropdownNotifications')?.addEventListener('click', () => {
        this.requestNotificationPermission();
      });

      document.addEventListener('click', async (e) => {
        const notificationItem = e.target.closest('.notification-item');
        if (notificationItem) {
          e.preventDefault();
          await this.handleNotificationClick(notificationItem);
          return;
        }

        const ticketLink = this.findTicketLink(e.target);
        if (ticketLink) {
          e.preventDefault();
          await this.handleTicketClick(ticketLink);
        }
      });
    }

    async loadNotifications() {
      if (this.state.isFetching) return;
      this.state.isFetching = true;

      try {
        const response = await fetch(config.baseUrl + config.endpoints.notifications);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const notifications = await response.json();
        this.state.notifications = notifications;

        this.renderNotifications(notifications);
        this.processUnreadNotifications(notifications);
      } catch (error) {
        console.error('Error cargando notificaciones:', error);
        this.showErrorState();
      } finally {
        this.state.isFetching = false;
      }
    }

    renderNotifications(notifications) {
      if (!notifications.length) {
        this.elements.container.innerHTML = `
          <li class="nav-item py-2 px-3">
            <div class="text-center text-muted small">
              No hay notificaciones nuevas
            </div>
          </li>`;
        this.updateBadge(0); // Actualizar badge a cero
        return;
      }

      this.elements.container.innerHTML = notifications.map(notif => `
        <li class="nav-item">
          <a class="dropdown-item notification-item d-flex align-items-center py-2" 
             href="${this.sanitizeUrl(notif.link)}" 
             data-id="${notif.id}">
            <div class="flex-shrink-0 me-3">
              <div class="bg-${this.getPriorityClass(notif.priority)} rounded-circle p-2">
                <i class="bi ${this.getNotificationIcon(notif.type)} text-white"></i>
              </div>
            </div>
            <div class="w-100 flex-grow-1">
              <div class="mb-1">${this.escapeHtml(notif.title) || 'Notificación'}</div>
              <div class="text-muted small">
                ${this.escapeHtml(notif.message)}
                <div class="text-primary">${notif.time || 'Reciente'}</div>
              </div>
            </div>
          </a>
        </li>
      `).join('');

      this.updateBadge(notifications.filter(n => !n.is_read).length);
    }

    processUnreadNotifications(notifications) {
      notifications.filter(n => !n.is_read).forEach(notif => {
        if (notif.play_sound) this.playSound(notif.priority);
        this.showToast(notif);
      });
    }

    async handleNotificationClick(notificationItem) {
      const notificationId = notificationItem.dataset.id;
      const href = notificationItem.href;

      if (notificationId) {
        await this.markAsRead([notificationId]);
      }
      window.location.href = href;
    }

    async handleTicketClick(link) {
      const ticketId = link.dataset.id;
      if (!ticketId) return;

      try {
        await this.markAsRead([ticketId]);
        this.updateTicketUI(link);
        window.location.href = link.href;
      } catch (error) {
        console.error('Error procesando ticket:', error);
        window.location.href = link.href;
      }
    }

    updateTicketUI(link) {
      const badge = link.closest('tr')?.querySelector('.badge-unread-status');
      if (badge) {
        badge.classList.replace('bg-danger', 'bg-success');
        badge.textContent = 'Leído';
      }
    }

    showToast(notification) {
      if (!window.Toastastic) {
        console.warn('Toastastic no está disponible');
        return;
      }

      const options = {
        message: notification.message,
        duration: config.intervals.toast,
        position: 'top-right',
        closeButton: true,
        onClick: () => {
          this.markAsRead([notification.id]);
          window.location.href = notification.link;
        }
      };

      const type = this.getToastType(notification.type || notification.priority);
      if (Toastastic[type]) {
        Toastastic[type](notification.message, options);
      } else {
        Toastastic.custom({ ...options, type });
      }
    }

    playSound(priority = 'baja') {
      const soundFile = config.sounds[priority] || config.sounds['baja'];

      try {
        if (!this.state.soundCache[soundFile]) {
          this.state.soundCache[soundFile] = new Audio(config.baseUrl + config.paths.sounds + soundFile);
        }

        const audio = this.state.soundCache[soundFile];
        audio.currentTime = 0;
        audio.volume = 0.7;
        audio.play().catch(e => console.log('Reproducción bloqueada:', e));
      } catch (error) {
        console.error('Error reproduciendo sonido:', error);
      }
    }

    async markAsRead(ids) {
      if (!ids?.length) return false;

      const validIds = ids.map(id => parseInt(id)).filter(id => !isNaN(id) && id > 0);
      if (!validIds.length) return false;

      try {
        const response = await fetch(`${config.baseUrl}/admin/tickets/markasread`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Requested-With': 'XMLHttpRequest'
          },
          body: JSON.stringify({ ids: validIds })
        });

        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const result = await response.json();

        if (!result.success) {
          console.error('Error del servidor:', result.message);
          return false;
        }

        // Actualización local optimizada
        this.handleMarkedAsRead(validIds, result.updated);
        return true;

      } catch (error) {
        console.error('Error en markAsRead:', error);
        return false;
      }
    }

    handleMarkedAsRead(ids, updatedCount) {
      console.log(`Notificaciones marcadas como leídas: ${updatedCount}`);

      // Actualizar estado
      this.state.notifications = this.state.notifications.map(notif =>
        ids.includes(parseInt(notif.id)) ? { ...notif, is_read: 1 } : notif
      );

      // Actualizar UI
      this.updateDropdown(this.state.notifications);

      // Buscar todos los elementos afectados
      const selector = ids.map(id => `[data-id="${id}"]`).join(', ');
      document.querySelectorAll(selector).forEach(element => {
        // Actualizar badges
        const badge = element.closest('tr, .list-group-item')?.querySelector('.badge-unread-status');
        if (badge) {
          badge.classList.replace('bg-danger', 'bg-success');
          badge.textContent = 'Leído';
        }

        // Actualizar filas de tabla si existen
        const row = element.closest('tr');
        if (row) {
          row.classList.remove('unread-row');
        }
      });
    }

    findTicketLink(element) {
      const link = element.closest('a[data-id]');
      if (!link) return null;
      return /(tickets|admin\/tickets)/i.test(link.href) ? link : null;
    }

    updateDropdown(notifications) {
      if (!this.elements.container) return;

      // Filtrar notificaciones no leídas para el badge
      const unreadCount = notifications.filter(n => !n.is_read).length;
      this.updateBadge(unreadCount);

      // Generar HTML para las notificaciones
      this.elements.container.innerHTML = notifications.length
        ? this.generateNotificationsHTML(notifications)
        : this.generateEmptyNotificationHTML();
    }

    generateNotificationsHTML(notifications) {
      return notifications.map(notif => `
      <li class="nav-item">
        <a class="dropdown-item notification-item d-flex align-items-center py-2 ${!notif.is_read ? 'unread' : ''}" 
           href="${this.sanitizeUrl(notif.link)}" 
           data-id="${notif.id}">
          <div class="flex-shrink-0 me-3">
            <div class="bg-${this.getPriorityClass(notif.priority)} rounded-circle p-2">
              <i class="bi ${this.getNotificationIcon(notif.type)} text-white"></i>
            </div>
          </div>
          <div class="w-100 flex-grow-1">
            <div class="mb-1">${this.escapeHtml(notif.title) || 'Notificación'}</div>
            <div class="text-muted small">
              ${this.escapeHtml(notif.message)}
              <div class="text-primary">${notif.time || 'Reciente'}</div>
            </div>
          </div>
        </a>
      </li>
    `).join('');
    }

    generateEmptyNotificationHTML() {
      return `
      <li class="nav-item py-2 px-3">
        <div class="text-center text-muted small">
          No hay notificaciones nuevas
        </div>
      </li>`;
    }


    getPriorityClass(priority) {
      const priorityMap = {
        'alta': 'danger',
        'media': 'warning',
        'baja': 'success'
      };
      return priorityMap[priority?.toLowerCase()] || 'info';
    }

    getNotificationIcon(type) {
      const iconMap = {
        'new_ticket': 'bi-ticket-detailed',
        'ticket_update': 'bi-arrow-repeat',
        'ticket_closed': 'bi-check2-circle',
        'assignment': 'bi-person-exclamation'
      };
      return iconMap[type] || 'bi-bell';
    }

    getToastType(type) {
      return {
        'new_ticket': 'info',
        'ticket_update': 'warning',
        'ticket_closed': 'success',
        'assignment': 'info',
        'alta': 'error',
        'media': 'warning',
        'baja': 'info'
      }[type] || 'info';
    }

    sanitizeUrl(url) {
      if (!url) return '#';
      try {
        return new URL(url, config.baseUrl).href;
      } catch {
        return '#';
      }
    }

    escapeHtml(str) {
      return str?.toString()
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;') || '';
    }

    startPolling() {
      this.state.pollingInterval = setInterval(
        () => this.loadNotifications(),
        config.intervals.polling
      );
    }

    requestNotificationPermission() {
      if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission().then(permission => {
          console.log('Permiso de notificación:', permission);
        });
      }
    }

    showErrorState() {
      if (this.elements.container) {
        this.elements.container.innerHTML = `
          <li class="nav-item py-2 px-3">
            <div class="text-center text-danger small">
              Error cargando notificaciones
            </div>
          </li>`;
      }
      this.updateBadge(0); // Resetear badge en caso de error
    }

    getTicketIdFromUrl() {
      try {
        const pathMatch = window.location.pathname.match(/(?:tickets|admin\/tickets)\/details\/(\d+)/i);
        if (pathMatch?.[1]) return parseInt(pathMatch[1]);

        const urlParams = new URLSearchParams(window.location.search);
        const idParam = urlParams.get('id') || urlParams.get('ticket_id');
        if (idParam && !isNaN(idParam)) return parseInt(idParam);

        const activeElement = document.activeElement?.closest('[data-id]');
        if (activeElement?.dataset?.id) {
          const id = parseInt(activeElement.dataset.id);
          if (!isNaN(id)) return id;
        }
      } catch (e) {
        console.error('Error obteniendo ID del ticket:', e);
      }
      return null;
    }

    debug() {
      console.group('NotificationManager Debug');
      console.log('Estado:', this.state);
      console.log('Config:', config);
      console.log('Notificaciones:', this.state.notifications);
      console.log('Elementos:', this.elements);
      console.log('Sonidos precargados:', Object.keys(this.state.soundCache));
      console.groupEnd();
    }
  }

  // Inicialización
  document.addEventListener('DOMContentLoaded', () => {
    try {
      window.NotificationManager = new NotificationManager();
      window.debugNotifications = () => window.NotificationManager?.debug();
    } catch (error) {
      console.error('Error inicializando NotificationManager:', error);
    }
  });
})();